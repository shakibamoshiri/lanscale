#!/bin/bash


################################################################################
#
# bash strict mode
#
################################################################################
private::strict_mode(){
    set -T # inherit DEBUG and RETURN trap for functions
    set -C # prevent file overwrite by > &> <>
    set -E # inherit -e
    set -e # exit immediately on errors
    set -u # exit on not assigned variables
    set -o pipefail # exit on pipe failure
}
private::strict_mode;

#four functions to change output in color
private::info() { printf "\033[1;34m${*}\033[0m\n"; }
private::warn() { printf "\033[1;33m${*}\033[0m\n" 1>&2; }
private::error(){ printf "\033[1;31m${*}\033[0m\n" 1>&2; }
private::title(){ printf "\033[1;37m${*}\033[0m\n"; }

# mutable variables
declare SCRIPT_DEBUG_FLAG=false;

# immutable variables
declare -ir ERR_EXPR_FAILED=1;
declare -ir ERR_FILE_NOT_FOUND=2;
declare -ir ERR_OPTION_NOT_FOUND=3;
declare -ir EXIT_SUCCESS=0;
declare -ir CLI_PPID=$$;

# declare -rA SUBCMD=([help]=help [config]=config [Test]=Test [EnumUser]=EnumUser);
# declare -r PS4='debug($LINENO) ${FUNCNAME[0]:+${FUNCNAME[0]}}(): ';
declare -r CLI_NAME='lanscale';
declare -r CLI_VERSION='0.0.1';
declare -r CLI_INSTALL_PATH='/usr/local/bin';
declare -r HELP_OFFSET=20;
declare -r ANSISHELL_HEADER='
 xxx
 xxx
 xxx
LAN Scale using SoftEther VPN';


declare -r __config_path='.';
declare -r __config_file="${__config_path}/sample.2.yaml"
declare -r __yaml="$(yq '.' < $__config_file)";

#declare -A __server;
#__server[host]=$(yq ".server.host" $__config_file);
#__server[port]=$(yq ".server.port" $__config_file);
#__server[pass]=$(yq ".server.pass" $__config_file);
#__server[vpncmd]=$(yq ".server.vpncmd" $__config_file);
#
#declare -r vpncmd="${__server[vpncmd]} ${__server[host]}:${__server[port]} /server /password:${__server[pass]} "



public::init(){
    declare -A __peers;
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    while read -a objects; do
        __peers[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades[] | select(.name==\"$__p_cc_name\")" <<< $__data);

    __local_hub=$(yq '.name' <<< $__data);

    # HubCreate [name] [/PASSWORD:password]
    { $vpncmd /cmd HubCreate $__local_hub /password:${__server[pass]} |& grep -A 3 ^HubCreate; } || true;

    # BridgeCreate [hubname] [/DEVICE:device_name] [/TAP:yes|no]
    $vpncmd /cmd BridgeCreate $__local_hub /tap:yes /device:${__peers[tap]} |& grep -A 3 ^BridgeCreate;

    # CascadeCreate [name] [/SERVER:hostname:port] [/HUB:hubname] [/USERNAME:username]
    $vpncmd /hub:$__local_hub /cmd CascadeCreate ${__peers[name]} /server:${__peers[host]}:${__peers[port]}  /hub:${__peers[hub]} /username:${__peers[user]} |& grep -A 3 ^CascadeCreate;

    # CascadePasswordSet [name] [/PASSWORD:password] [/TYPE:standard|radius]
    $vpncmd /hub:$__local_hub /cmd CascadePasswordSet ${__peers[name]} /password:${__peers[pass]} /type:standard  |& grep -A 3 ^CascadePasswordSet;
}

public::deinit(){
    set +e;
    declare -A __peers;
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    while read -a objects; do
        __peers[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades[] | select(.name==\"$__p_cc_name\")" <<< $__data);

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOffline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeOffline ${__peers[name]} |& grep -A 3 ^CascadeOffline;

    # CascadeDelete [name]
    $vpncmd /hub:$__local_hub /cmd CascadeDelete ${__peers[name]} |& grep -A 3 ^CascadeDelete;

    # BridgeDelete [hubname] [/DEVICE:device_name]
    $vpncmd /cmd  BridgeDelete $__local_hub /device:${__peers[tap]} |& grep -A 3 ^BridgeDelete;

    # HubDelete [name]
    { $vpncmd /cmd HubDel $__local_hub |& grep -A 3 ^HubDel; } || true;
    set -e;
}

public::online(){
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOnline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeOnline $__p_cc_name |& grep ^CascadeOnline -A 100;
}

public::offline(){
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOffline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeOffline $__p_cc_name |& grep ^CascadeOffline -A 100;
}

public::up(){
    declare -A __peers;
    declare __data __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    while read -a objects; do
        __peers[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades[] | select(.name==\"$__p_cc_name\")" <<< $__data);

    ip address add ${__peers[ip]}/${__peers[subnet]} brd + dev ${__peers[tap]}
    ip -brief  addr show dev ${__peers[tap]}
}

public::down(){
    declare -A __peers;
    declare __data __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    while read -a objects; do
        __peers[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades[] | select(.name==\"$__p_cc_name\")" <<< $__data);

    ip address del ${__peers[ip]}/${__peers[subnet]} brd + dev ${__peers[tap]}
}

public::get(){
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOnline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeGet $__p_cc_name |& grep ^CascadeGet -A 100;
}

public::list(){
    declare -A __local_hub __data;

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOnline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeList |& grep ^CascadeList -A 1000;
}

private::install_dev(){
    declare -n __info=$1;

    declare install_se_server="function install_se_server(){
        set -x;
        apt-get update -y
        apt-get install -y build-essential git curl tree wget
        apt-get install -y cmake gcc g++ make libncurses5-dev libssl-dev libsodium-dev libreadline-dev zlib1g-dev pkg-config
        mkdir -p ${__info[path]}
        cd ${__info[path]}
        ls -la
        git clone ${__info[repo]} dev || true
        cd dev
        git submodule init
        git submodule update
        ./configure
        make -C build
        cd build
        ls -la
    }";

    eval "$install_se_server";
    install_se_server="$(declare -f install_se_server); install_se_server;"

    printf '%s\n' "$install_se_server";
}


private::install_stable(){
    declare -n __info=$1;

    declare install_se_server="function install_se_server(){
        set -x;
        apt-get update -y
        apt-get install -y build-essential git curl tree wget
        mkdir -p ${__info[path]}
        cd ${__info[path]}
        ls -la
        wget --show-progress -qc  ${__info[link]}
        tar xzf ${__info[link]##*/}
        test -f vpnserver
        chmod 0755 vpnserver
        mv vpnserver stable
        cd stable
        chmod 600 *
        make
        ls -la
    }";

    eval "$install_se_server";
    install_se_server="$(declare -f install_se_server); install_se_server;"

    printf '%s\n' "$install_se_server";
}

private::pass_stable(){
    declare -n __info=$1;

    # vpncmd [host:port] [/CLIENT|/SERVER|/TOOLS] [/HUB:hub] [/ADMINHUB:adminhub] [/PASSWORD:password] [/IN:infile] [/OUT:outfile] [/CMD commands...]

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        cd ${__info[path]}/stable;
        test -f ./vpnserver
        ./vpncmd localhost:443 /SERVER /PASSWORD: /cmd HubDel DEFAULT
        ./vpncmd localhost:443 /SERVER /PASSWORD: /cmd HubCreate ${__info[hub]} /PASSWORD:${__info[pass]}
        ./vpncmd localhost:443 /SERVER /PASSWORD: /cmd HubList
        ./vpncmd localhost:443 /SERVER /PASSWORD: /cmd ServerPasswordSet ${__info[pass]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::systemd_stable(){
    declare -n __info=$1;
    declare -r __bin_path="${__info[path]}/stable";

    declare install_systemd="function install_systemd(){
        set -x;
        echo '[Unit]
Description=SoftEther VPN Server
After=network.target auditd.service

[Service]
Type=forking
TasksMax=infinity
EnvironmentFile=-${__bin_path}
ExecStart=${__bin_path}/vpnserver start
ExecStop=${__bin_path}/vpnserver stop
KillMode=process
Restart=on-failure

# Hardening
PrivateTmp=yes
ProtectHome=yes
ProtectSystem=full
ReadOnlyDirectories=/
ReadWriteDirectories=-${__bin_path}

[Install]
WantedBy=multi-user.target' > /usr/lib/systemd/system/se-stable.service;

        systemctl daemon-reload
    }";

    eval "$install_systemd";
    install_systemd="$(declare -f install_systemd); install_systemd;"

    printf '%s\n' "$install_systemd";
}

private::systemd_dev(){
    echo systemd dev ...
}

private::start_stable(){
    declare start_systemd="function start_systemd(){
        set -x;
        systemctl start se-stable.service
    }";

    eval "$start_systemd";
    start_systemd="$(declare -f start_systemd); start_systemd;"

    printf '%s\n' "$start_systemd";
}

private::stop_stable(){
    declare stop_systemd="function stop_systemd(){
        set -x;
        systemctl stop se-stable.service
    }";

    eval "$stop_systemd";
    stop_systemd="$(declare -f stop_systemd); stop_systemd;"

    printf '%s\n' "$stop_systemd";
}

private::restart_stable(){
    declare restart_systemd="function restart_systemd(){
        set -x;
        systemctl restart se-stable.service
    }";

    eval "$restart_systemd";
    restart_systemd="$(declare -f restart_systemd); restart_systemd;"

    printf '%s\n' "$restart_systemd";
}

public::server(){
    declare -A __s_info __action_list;
    declare -a __action_list_order;
    declare __s_name __s_action;

    __action_list_order=(install systemd pass start stop restart);

    __action_list[install]='install SoftEther VPN server'
    __action_list[systemd]='install systemd service'
    __action_list[start]='start systemd serivce'
    __action_list[stop]='stop systemd service'
    __action_list[restart]='restart systemd service';
    __action_list[pass]='set password for admin';

    if [[ -z ${1:-} ]]; then
        while read name; do
            echo server: $name;
        done < <(yq '.server | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __s_name="${1}";

    while read -a objects; do
        __s_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".server.${__s_name}" <<< "$__yaml");

    if [[ -z ${2:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __s_action="$2";
    fi


    if [[ -n  ${__s_info[link]:-} ]]; then
        # echo link: ${__s_info[link]}
        # private::install_stable __s_info;
        # ssh ${__s_info[ssh]} "$(private::install_stable __s_info)"
        __s_action+='_stable'

    else
        # echo repo: ${__s_info[repo]}
        # private::install_dev __s_info;
        # ssh ${__s_info[ssh]} "$(private::install_dev __s_info)"
        __s_action+='_dev'
    fi
    

    case $__s_action in
        install_stable )
            echo ${__s_action//_/ };
        ;;
        install_dev )
            echo ${__s_action//_/ };
        ;;

        pass_dev | pass_stable )
            echo ${__s_action//_/ };
        ;;

        systemd_stable )
            echo ${__s_action//_/ };
        ;;
        systemd_dev )
            echo ${__s_action//_/ };
        ;;

        start_stable )
            echo ${__s_action//_/ };
        ;;
        stop_stable  )
            echo ${__s_action//_/ };
        ;;
        restart_stable  )
            echo ${__s_action//_/ };
        ;;

        start_dev )
            echo ${__s_action//_/ };
        ;;
        stop_dev  )
            echo ${__s_action//_/ };
        ;;
        restart_dev  )
            echo ${__s_action//_/ };
        ;;

        * )
            printf 'action %s not found\n' $__s_action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac

    read -p 'continue? [p/n/Y] ';
    if [[ $REPLY == Y || $REPLY == y ]]; then
        ssh ${__s_info[ssh]} "$(private::$__s_action __s_info)"
    elif [[ $REPLY == p ]]; then
        private::$__s_action __s_info;
    else
        printf 'cancelled!\n';
    fi

    echo done;
}


private::hub_add(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # HubCreate [name] [/PASSWORD:password]
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
            HubCreate ${__hub[hub]} /PASSWORD:${__hub[pass]} | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_delete(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # HubCreate [name] [/PASSWORD:password]
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
            HubDelete ${__hub[hub]} | column -s, -t
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_online(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/Online
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            Online | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_offline(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/Offline
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            Offline | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_status(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/StatusGet
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            StatusGet | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_list(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # HubList
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
            HubList | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

# Hub              - Select Virtual Hub to Manage
# HubCreate        - Create New Virtual Hub
# HubCreateDynamic - Create New Dynamic Virtual Hub (For Clustering)
# HubCreateStatic  - Create New Static Virtual Hub (For Clustering)
# HubDelete        - Delete Virtual Hub
# HubList          - Get List of Virtual Hubs
# HubSetDynamic    - Change Virtual Hub Type to Dynamic Virtual Hub
# HubSetStatic     - Change Virtual Hub Type to Static Virtual Hub
public::hubs(){
    declare -A __hub_info __server_info __action_list __;
    declare -a __action_list_order;
    declare __server_name __hub_name __action __function;

    __action_list_order=(add delete online offline status list);

    __action_list[add]='add a hub'
    __action_list[delete]='delete a hub'
    __action_list[online]='make a hub online'
    __action_list[offline]='make a hub offline'
    __action_list[list]='list all hub(s)'
    __action_list[status]='status a hub offline'

    ### match server name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq '.hubs | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __server_name=${1};
    shift 1;
    
    ### lookup server info in .servers
    while read -a objects; do
        __server_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".server.${__server_name}" <<< "$__yaml");

    if [[ -n  ${__server_info[link]:-} ]]; then
        __server_info[cmd]="${__server_info[path]}/stable/vpncmd";
    else
        __server_info[cmd]="${__server_info[path]}/dev/build/vpncmd";
    fi
    
    private::debug $LINENO '!__server_info[@]:' "'${!__server_info[@]}'";
    private::debug $LINENO '__server_info[@]:' "'${__server_info[@]}'";

    ### match hub name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".hubs.${__server_name}[].hub" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __hub_name=${1};
    shift 1;

    while read -a objects; do
        __hub_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".hubs.${__server_name}[] | select(.hub==\"${__hub_name}\") " <<< "$__yaml");

    private::debug $LINENO '!__hub_info[@]:' "'${!__hub_info[@]}'";
    private::debug $LINENO '__hub_info[@]:' "'${__hub_info[@]}'";

    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action="$1";
    fi




    case ${__action} in
        add | delete | online | offline | status | list )
            printf 'object: %s\n' ${FUNCNAME##*:}
            printf 'server: %s\n' $__server_name;
            printf 'hub: %s\n'  $__hub_name
            printf 'action: %s\n' $__action
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                 ssh ${__server_info[ssh]} "$(private::hub_${__action} __server_info __hub_info)";
            elif [[ $REPLY == p ]]; then
                private::hub_${__action} __server_info __hub_info;
            else
                printf 'cancelled!\n';
            fi

        ;;
        * )
            printf 'action %s not found\n' $__action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac

    echo done;

}

















private::user_add(){
    declare -n __user=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserCreate [name] [/GROUP:group] [/REALNAME:realname] [/NOTE:note]
        ${__hub[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__hub[pass]} /CSV /CMD \
            UserCreate ${__user[username]} /GROUP: /REALNAME:${__user[realname]} /NOTE:${__user[note]};
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::user_delete(){
    declare -n __user=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserDelete [name]
        ${__hub[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__hub[pass]} /CSV /CMD \
            UserDelete ${__user[username]};
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_pass(){
    declare -n __user=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserPasswordSet [name] [/PASSWORD:password]
        ${__hub[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__hub[pass]} /CSV /CMD \
            UserPasswordSet ${__user[username]} /PASSWORD:${__user[password]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_date(){
    declare -n __user=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserExpiresSet [name] [/EXPIRES:expires]
        ${__hub[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__hub[pass]} /CSV /CMD \
            UserExpiresSet ${__user[username]} /EXPIRES:\"${__user[expire]} 23:59:59\"
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_set(){
    declare -n __user=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        #  UserSet [name] [/GROUP:group] [/REALNAME:realname] [/NOTE:note]
        ${__hub[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__hub[pass]} /CSV /CMD \
            UserSet ${__user[username]} /GROUP:${__user[group]} /REALNAME:${__user[realname]} /NOTE:${__user[note]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_get(){
    declare -n __user=${1};
    declare -n __hub=${2};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        ${__hub[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__hub[pass]} /CSV  /CMD UserGet ${__user[username]} | column -s, -t
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::user_list(){
    declare -n __user=${1};
    declare -n __hub=${2};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        ${__hub[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__hub[pass]} /CSV  /CMD UserList | column -s, -t
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

public::users(){
    declare -A __user_info __hub_info __action_list;
    declare -a __action_list_order;
    declare __s_name __hub_name __user_name __u_action __function;

    __action_list_order=(add delete pass date set get list);

    __action_list[add]='add a user'
    __action_list[delete]='delete a user'
    __action_list[pass]='set password for a user'
    __action_list[date]='set expire date date for a user'
    __action_list[set]='update a user user information'
    __action_list[get]='get info for a user'
    __action_list[list]='list of users'

    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq '.users | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __s_name=${1};
    shift 1;
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".users.${__s_name}[].hub" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __hub_name=${1};
    shift 1;

    while read -a objects; do
        __hub_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".users.${__s_name}[] | select(.hub==\"${__hub_name}\") | del(.users)" <<< "$__yaml");

    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".users.${__s_name}[] | select(.hub==\"${__hub_name}\") | .users[].username " <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __user_name=${1};
    shift 1;
    while read -a objects; do
        __user_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".users.${__s_name}[] | select(.hub==\"${__hub_name}\") | .users[] | select(.username==\"${__user_name}\") " <<< "$__yaml");

    echo __user_info: "${__user_info[@]}"


    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __u_action="$1";
    fi

    case ${__u_action} in
        add | delete | pass | date | set | get | list )
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                 ssh ${__hub_info[ssh]} "$(private::user_${__u_action} __user_info __hub_info)";
            elif [[ $REPLY == p ]]; then
                private::user_${__u_action} __user_info __hub_info
            else
                printf 'cancelled!\n';
            fi

        ;;
        * )
            printf 'action %s not found\n' $__u_action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac

    echo done;
}





public::peers(){
    if [[ -z ${1:-} ]]; then
        yq '.peers[].name' <<< "$__yaml"
        exit $EXIT_SUCCESS;
    fi

    declare __local_hub="${1:? ... Error: peers hub name?}";
    shift 1;

    if [[ -z ${1:-} ]]; then
        yq ".peers[] | select(.name==\"$__local_hub\") | .cascades[].name" <<< "$__yaml"
        exit $EXIT_SUCCESS;
    fi

    declare __p_cc_name="${1:? ... Error: peers hub cc name?}";
    shift 1;

    if [[ -z ${1:-} ]]; then
        for cmd in print init deinit online offline up donw get list; do
            printf '%s\n' $cmd;
        done
        exit $EXIT_SUCCESS;
    fi
    
    declare __p_action="${1:? ... Error: peers hub cc action??}";

    shift 1;
    if [[ $__p_action == 'print' ]]; then
        yq ".peers[] | select(.name==\"$__local_hub\") | .cascades[] | select(.name==\"$__p_cc_name\")" <<< "$__yaml";
        # yq ".peers[] | select(.name==\"$__local_hub\") " <<< "$__yaml";
    else
        cd ${__server[vpncmd]%vpncmd};
        # yq ".peers[] | select(.name==\"$__local_hub\") | .cascades[] | select(.name==\"$__p_cc_name\")" <<< "$__yaml" | public::${__p_action};
        yq ".peers[] | select(.name==\"$__local_hub\")" <<< "$__yaml" | public::${__p_action} $__p_cc_name;
    fi
    # $vpncmd /hub:$__local_hub /cmd help;

}










private::debug(){
    if [[ $SCRIPT_DEBUG_FLAG == true ]]; then
        private::warn "script($1)"  "${@:2}";
    fi
}

private::debug_x(){
    set -x;
}

private::main_help(){
    printf "$ANSISHELL_HEADER";

    printf "\n\nusage:\n";
    printf "$CLI_NAME [--options]\n";
    printf "$CLI_NAME command [--options]\n";
    printf "$CLI_NAME [--options] command [--options]\n";

    printf "\noptions:\n";
    printf "%-${HELP_OFFSET}s %s\n" '-h  | --help' 'show this help menu';
    printf "%-${HELP_OFFSET}s %s\n" '-v  | --version' 'show version';
    printf "%-${HELP_OFFSET}s %s\n" '-i  | --install' 'install this CLI';
    printf "%-${HELP_OFFSET}s %s\n" '-e  | --example' 'show some examples';
    printf "%-${HELP_OFFSET}s %s\n" '-d  | --debug' 'enable debugging (script level)';
    printf "%-${HELP_OFFSET}s %s\n" '-D  | --debug-x' 'enable bash debugging (bash level)';

    printf "\ncommands:\n";
    printf "%-${HELP_OFFSET}s %s\n" 'help' 'show help menu';
    printf "%-${HELP_OFFSET}s %s\n" 'peers' 'a user functions';
    printf "%-${HELP_OFFSET}s %s\n" 'init' 'a session functions';
    printf "%-${HELP_OFFSET}s %s\n" 'deinit' 'read SE server admin yaml file';
    printf "%-${HELP_OFFSET}s %s\n" 'online' 'send RPC-JSON to SE server';
    printf "%-${HELP_OFFSET}s %s\n" 'offline' 'parse SE server response';
    printf "%-${HELP_OFFSET}s %s\n" 'up' 'reset Bytes and Counts';
    printf "%-${HELP_OFFSET}s %s\n" 'down' 'reset Bytes and Counts';

    exit ${1:-1};
}

private::parse_options(){
    if (( ${#} == 0 )); then
        private::main_help 0;
    fi

    case $1 in
        -h | --help )
            private::main_help 0;
        ;;
        -d | --debug )
            SCRIPT_DEBUG_FLAG=true
            shift;
        ;;
        -D | --debug-x )
            private::debug_x;
            shift;
        ;;
        -e | --example )
            private::example;
            shift;
        ;;
        -v | --version )
            private::cli_version;
            shift;
        ;;
        -i | --install )
            private::cli_install;
        ;;
    esac

    if (( ${#} != 0 )); then
        private::debug $LINENO continue-main: "'$@'";
        private::main "$@";
    fi
}


private::main(){
    if (( ${#} == 0 )); then
        private::main_help 0;
    fi

    case ${1} in
        help | peers | server | hubs | users )
            private::debug $LINENO 'command:' "'${1}'";
            private::debug $LINENO 'command-options:' "'${@:2}'";
            public::${1} "${@:2}";
        ;;
        * )
            private::parse_options "$@";
        ;;
    esac
}

private::main "$@";
