#!/bin/bash


################################################################################
#
# bash strict mode
#
################################################################################
private::strict_mode(){
    set -T # inherit DEBUG and RETURN trap for functions
    set -C # prevent file overwrite by > &> <>
    set -E # inherit -e
    set -e # exit immediately on errors
    set -u # exit on not assigned variables
    set -o pipefail # exit on pipe failure
}
private::strict_mode;

#four functions to change output in color
private::info() { printf "\033[1;34m${*}\033[0m\n"; }
private::warn() { printf "\033[1;33m${*}\033[0m\n" 1>&2; }
private::error(){ printf "\033[1;31m${*}\033[0m\n" 1>&2; }
private::title(){ printf "\033[1;37m${*}\033[0m\n"; }

# mutable variables
declare SCRIPT_DEBUG_FLAG=false;

# immutable variables
declare -ir ERR_EXPR_FAILED=1;
declare -ir ERR_FILE_NOT_FOUND=2;
declare -ir ERR_OPTION_NOT_FOUND=3;
declare -ir EXIT_SUCCESS=0;
declare -ir CLI_PPID=$$;

# declare -rA SUBCMD=([help]=help [config]=config [Test]=Test [EnumUser]=EnumUser);
# declare -r PS4='debug($LINENO) ${FUNCNAME[0]:+${FUNCNAME[0]}}(): ';
declare -r CLI_NAME='lanscale';
declare -r CLI_VERSION='0.0.1';
declare -r CLI_INSTALL_PATH='/usr/local/bin';
declare -r HELP_OFFSET=20;
declare -r ANSISHELL_HEADER='
 xxx
 xxx
 xxx
LAN Scale using SoftEther VPN';


declare -r __config_path='.';
declare -r __config_file="${__config_path}/sample.2.yaml"
declare -r __yaml="$(yq '.' < $__config_file)";

#declare -A __server;
#__server[host]=$(yq ".server.host" $__config_file);
#__server[port]=$(yq ".server.port" $__config_file);
#__server[pass]=$(yq ".server.pass" $__config_file);
#__server[vpncmd]=$(yq ".server.vpncmd" $__config_file);
#
#declare -r vpncmd="${__server[vpncmd]} ${__server[host]}:${__server[port]} /server /password:${__server[pass]} "



public::init(){
    declare -A __peers;
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    while read -a objects; do
        __peers[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades[] | select(.name==\"$__p_cc_name\")" <<< $__data);

    __local_hub=$(yq '.name' <<< $__data);

    # HubCreate [name] [/PASSWORD:password]
    { $vpncmd /cmd HubCreate $__local_hub /password:${__server[pass]} |& grep -A 3 ^HubCreate; } || true;

    # BridgeCreate [hubname] [/DEVICE:device_name] [/TAP:yes|no]
    $vpncmd /cmd BridgeCreate $__local_hub /tap:yes /device:${__peers[tap]} |& grep -A 3 ^BridgeCreate;

    # CascadeCreate [name] [/SERVER:hostname:port] [/HUB:hubname] [/USERNAME:username]
    $vpncmd /hub:$__local_hub /cmd CascadeCreate ${__peers[name]} /server:${__peers[host]}:${__peers[port]}  /hub:${__peers[hub]} /username:${__peers[user]} |& grep -A 3 ^CascadeCreate;

    # CascadePasswordSet [name] [/PASSWORD:password] [/TYPE:standard|radius]
    $vpncmd /hub:$__local_hub /cmd CascadePasswordSet ${__peers[name]} /password:${__peers[pass]} /type:standard  |& grep -A 3 ^CascadePasswordSet;
}

public::deinit(){
    set +e;
    declare -A __peers;
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    while read -a objects; do
        __peers[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades[] | select(.name==\"$__p_cc_name\")" <<< $__data);

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOffline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeOffline ${__peers[name]} |& grep -A 3 ^CascadeOffline;

    # CascadeDelete [name]
    $vpncmd /hub:$__local_hub /cmd CascadeDelete ${__peers[name]} |& grep -A 3 ^CascadeDelete;

    # BridgeDelete [hubname] [/DEVICE:device_name]
    $vpncmd /cmd  BridgeDelete $__local_hub /device:${__peers[tap]} |& grep -A 3 ^BridgeDelete;

    # HubDelete [name]
    { $vpncmd /cmd HubDel $__local_hub |& grep -A 3 ^HubDel; } || true;
    set -e;
}

public::online(){
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOnline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeOnline $__p_cc_name |& grep ^CascadeOnline -A 100;
}

public::offline(){
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOffline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeOffline $__p_cc_name |& grep ^CascadeOffline -A 100;
}

public::up(){
    declare -A __peers;
    declare __data __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    while read -a objects; do
        __peers[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades[] | select(.name==\"$__p_cc_name\")" <<< $__data);

    ip address add ${__peers[ip]}/${__peers[subnet]} brd + dev ${__peers[tap]}
    ip -brief  addr show dev ${__peers[tap]}
}

public::down(){
    declare -A __peers;
    declare __data __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    while read -a objects; do
        __peers[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades[] | select(.name==\"$__p_cc_name\")" <<< $__data);

    ip address del ${__peers[ip]}/${__peers[subnet]} brd + dev ${__peers[tap]}
}

public::get(){
    declare __data __local_hub __p_cc_name;

    __p_cc_name=${1:? ... Error: __p_cc_name ?}

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOnline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeGet $__p_cc_name |& grep ^CascadeGet -A 100;
}

public::list(){
    declare -A __local_hub __data;

    if [[ -p /dev/stdin ]]; then
        __data=$(< /dev/stdin);
    else
        exit $ERR_EXPR_FAILED;
    fi

    __local_hub=$(yq '.name' <<< $__data);

    # CascadeOnline [name]
    $vpncmd /hub:$__local_hub /cmd CascadeList |& grep ^CascadeList -A 1000;
}






private::server_install(){
    declare -n __server=$1;

    if [[ ${__server[version]} == stable ]]; then
        declare install_se_stable="function install_se_stable(){
            set -x;
            apt-get update -y
            apt-get install -y build-essential git curl tree wget
            mkdir -p ${__server[path]}
            cd ${__server[path]}
            ls -la
            wget --show-progress -qc  ${__server[link]}
            tar xzf ${__server[link]##*/}
            test -f vpnserver
            chmod 0755 vpnserver
            mv vpnserver stable
            cd stable
            chmod 600 *
            make
            ls -la
        }";

        eval "$install_se_stable";
        install_se_stable="$(declare -f install_se_stable); install_se_stable;"

        printf '%s\n' "$install_se_stable";
    elif [[ ${__server[version]} == 'dev' ]]; then
        declare install_se_dev="function install_se_dev(){
            set -x;
            apt-get update -y
            apt-get install -y build-essential git curl tree wget
            apt-get install -y cmake gcc g++ make libncurses5-dev libssl-dev libsodium-dev libreadline-dev zlib1g-dev pkg-config
            mkdir -p ${__server[path]}
            cd ${__server[path]}
            ls -la
            git clone ${__server[repo]} dev || true
            cd dev
            git submodule init
            git submodule update
            ./configure
            make -C build
            cd build
            ls -la
        }";

        eval "$install_se_dev";
        install_se_dev="$(declare -f install_se_dev); install_se_dev;"

        printf '%s\n' "$install_se_dev";
    else
        printf '%s has no match\n' ${__server[version]};
    fi
}


private::server_systemd(){
    declare -n __server=$1;
    declare __bin_path;

    if [[ ${__server[version]} == 'stable' ]]; then
        __bin_path="${__server[path]}/${__server[version]}";
    elif [[ ${__server[version]} == 'dev' ]]; then
        __bin_path="${__server[path]}/${__server[version]}/build";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    declare install_systemd="function install_systemd(){
        set -x;
        echo '[Unit]
Description=SoftEther VPN Server
After=network.target auditd.service

[Service]
Type=forking
TasksMax=infinity
EnvironmentFile=-${__bin_path}
ExecStart=${__bin_path}/vpnserver start
ExecStop=${__bin_path}/vpnserver stop
KillMode=process
Restart=on-failure

# Hardening
PrivateTmp=yes
ProtectHome=yes
ProtectSystem=full
ReadOnlyDirectories=/
ReadWriteDirectories=-${__bin_path}

[Install]
WantedBy=multi-user.target' > /usr/lib/systemd/system/se-${__server[version]}.service;

        systemctl daemon-reload
    }";

    eval "$install_systemd";
    install_systemd="$(declare -f install_systemd); install_systemd;"

    printf '%s\n' "$install_systemd";
}

private::server_pass(){
    declare -n __server=$1;

    if [[ ${__server[version]} == 'stable' ]]; then
        __bin_path="${__server[path]}/${__server[version]}";
    elif [[ ${__server[version]} == 'dev' ]]; then
        __bin_path="${__server[path]}/${__server[version]}/build";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    # vpncmd [host:port] [/CLIENT|/SERVER|/TOOLS] [/HUB:hub] [/ADMINHUB:adminhub] [/PASSWORD:password] [/IN:infile] [/OUT:outfile] [/CMD commands...]

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        test -f ${__bin_path}/vpncmd
        test -f ${__bin_path}/vpnserver
        ${__bin_path}/vpncmd localhost:443 /SERVER /PASSWORD: /cmd ServerPasswordSet ${__server[pass]}
        ${__bin_path}/vpncmd localhost:443 /SERVER /PASSWORD:${__server[pass]} /cmd HubDel DEFAULT
        ${__bin_path}/vpncmd localhost:443 /SERVER /PASSWORD:${__server[pass]} /cmd HubCreate ${__server[hub]} /PASSWORD:${__server[pass]}
        ${__bin_path}/vpncmd localhost:443 /SERVER /PASSWORD:${__server[pass]} /cmd HubList
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::server_start(){
    declare -n __server=$1;
    declare lanscale_ssh_fn;

    if [[ ${__server[version]} == 'stable' ]]; then
        lanscale_ssh_fn="function lanscale_ssh_fn(){
            set -x;
            systemctl start se-stable.service
        }";
    elif [[ ${__server[version]} == 'dev' ]]; then
        lanscale_ssh_fn="function lanscale_ssh_fn(){
            set -x;
            systemctl start se-dev.service
        }";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::server_stop(){
    declare -n __server=$1;
    declare lanscale_ssh_fn;

    if [[ ${__server[version]} == 'stable' ]]; then
        lanscale_ssh_fn="function lanscale_ssh_fn(){
            set -x;
            systemctl stop se-stable.service
        }";
    elif [[ ${__server[version]} == 'dev' ]]; then
        lanscale_ssh_fn="function lanscale_ssh_fn(){
            set -x;
            systemctl stop se-dev.service
        }";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::server_restart(){
    declare -n __server=$1;
    declare lanscale_ssh_fn;

    if [[ ${__server[version]} == 'stable' ]]; then
        lanscale_ssh_fn="function lanscale_ssh_fn(){
            set -x;
            systemctl restart se-stable.service
        }";
    elif [[ ${__server[version]} == 'dev' ]]; then
        lanscale_ssh_fn="function lanscale_ssh_fn(){
            set -x;
            systemctl restart se-dev.service
        }";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::server_status(){
    declare -n __server=$1;

    if [[ ${__server[version]} == 'stable' ]]; then
        __bin_path="${__server[path]}/${__server[version]}";
    elif [[ ${__server[version]} == 'dev' ]]; then
        __bin_path="${__server[path]}/${__server[version]}/build";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        test -f ${__bin_path}/vpncmd
        test -f ${__bin_path}/vpnserver
        ${__bin_path}/vpncmd localhost:443 /SERVER /PASSWORD:${__server[pass]} /CSV /CMD ServerStatusGet | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::server_info(){
    declare -n __server=$1;

    if [[ ${__server[version]} == 'stable' ]]; then
        __bin_path="${__server[path]}/${__server[version]}";
    elif [[ ${__server[version]} == 'dev' ]]; then
        __bin_path="${__server[path]}/${__server[version]}/build";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        test -f ${__bin_path}/vpncmd
        test -f ${__bin_path}/vpnserver
        ${__bin_path}/vpncmd localhost:443 /SERVER /PASSWORD:${__server[pass]} /CSV /CMD ServerInfoGet | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

# ServerCertGet        - Get SSL Certificate of VPN Server
# ServerCertRegenerate - Generate New Self-Signed Certificate with Specified CN (Common Name) and Register on VPN Server
# ServerCertSet        - Set SSL Certificate and Private Key of VPN Server
# ServerCipherGet      - Get the Encrypted Algorithm Used for VPN Communication.
# ServerCipherSet      - Set the Encrypted Algorithm Used for VPN Communication.
# ServerInfoGet        - Get server information
# ServerKeyGet         - Get SSL Certificate Private Key of VPN Server
# ServerPasswordSet    - Set VPN Server Administrator Password
# ServerStatusGet      - Get Current Server Status
public::servers(){
    declare -A __s_info __action_list;
    declare -a __action_list_order;
    declare __s_name __s_action __server_version;

    __action_list_order=(install systemd pass start stop restart status info);

    __action_list[install]='install SoftEther VPN server'
    __action_list[systemd]='install systemd service'
    __action_list[start]='start systemd serivce'
    __action_list[stop]='stop systemd service'
    __action_list[restart]='restart systemd service';
    __action_list[pass]='set password for admin';
    __action_list[status]='get status of a server';
    __action_list[info]='get information of a server';

    if [[ -z ${1:-} ]]; then
        while read name; do
            echo $name;
        done < <(yq '.servers | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __s_name="${1}";

    while read -a objects; do
        __s_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".servers.${__s_name}" <<< "$__yaml");

    if [[ -z ${2:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __s_action="$2";
    fi


    if [[ -n  ${__s_info[link]:-} ]]; then
        __s_info[version]='stable';

    else
        # echo repo: ${__s_info[repo]}
        __s_info[version]='dev';
    fi
    

    case $__s_action in
        install | systemd | pass | start | stop | restart | status | info )
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                ssh ${__s_info[ssh]} "$(private::server_$__s_action __s_info)"
            elif [[ $REPLY == p ]]; then
                private::server_$__s_action __s_info;
            else
                printf 'cancelled\n';
            fi
        ;;

        * )
            printf 'action %s not found\n' $__s_action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac
}


private::hub_add(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # HubCreate [name] [/PASSWORD:password]
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
            HubCreate ${__hub[hub]} /PASSWORD:${__hub[pass]} | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_delete(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # HubCreate [name] [/PASSWORD:password]
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
            HubDelete ${__hub[hub]} | column -s, -t
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_online(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/Online
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            Online | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_offline(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/Offline
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            Offline | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_status(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/StatusGet
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            StatusGet | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_list(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # HubList
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
            HubList | column -s, -t;
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

# Hub              - Select Virtual Hub to Manage
# HubCreate        - Create New Virtual Hub
# HubCreateDynamic - Create New Dynamic Virtual Hub (For Clustering)
# HubCreateStatic  - Create New Static Virtual Hub (For Clustering)
# HubDelete        - Delete Virtual Hub
# HubList          - Get List of Virtual Hubs
# HubSetDynamic    - Change Virtual Hub Type to Dynamic Virtual Hub
# HubSetStatic     - Change Virtual Hub Type to Static Virtual Hub
public::hubs(){
    declare -A __hub_info __server_info __action_list __;
    declare -a __action_list_order;
    declare __server_name __hub_name __action __function;

    __action_list_order=(add delete online offline status list);

    __action_list[add]='add a hub'
    __action_list[delete]='delete a hub'
    __action_list[online]='make a hub online'
    __action_list[offline]='make a hub offline'
    __action_list[list]='list all hub(s)'
    __action_list[status]='status a hub offline'

    ### match server name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq '.hubs | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __server_name=${1};
    shift 1;
    
    ### lookup server info in .servers
    while read -a objects; do
        __server_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".servers.${__server_name}" <<< "$__yaml");

    if [[ -n  ${__server_info[link]:-} ]]; then
        __server_info[cmd]="${__server_info[path]}/stable/vpncmd";
    else
        __server_info[cmd]="${__server_info[path]}/dev/build/vpncmd";
    fi
    
    private::debug $LINENO '!__server_info[@]:' "'${!__server_info[@]}'";
    private::debug $LINENO '__server_info[@]:' "'${__server_info[@]}'";

    ### match hub name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".hubs.${__server_name}[].hub" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __hub_name=${1};
    shift 1;

    while read -a objects; do
        __hub_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".hubs.${__server_name}[] | select(.hub==\"${__hub_name}\") " <<< "$__yaml");

    private::debug $LINENO '!__hub_info[@]:' "'${!__hub_info[@]}'";
    private::debug $LINENO '__hub_info[@]:' "'${__hub_info[@]}'";

    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action="$1";
    fi




    case ${__action} in
        add | delete | online | offline | status | list )
            printf '%s > %s > %s > %s\n' ${FUNCNAME##*:} $__server_name $__hub_name $__action;
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                 ssh ${__server_info[ssh]} "$(private::hub_${__action} __server_info __hub_info)";
            elif [[ $REPLY == p ]]; then
                private::hub_${__action} __server_info __hub_info;
            else
                printf 'cancelled\n';
            fi

        ;;
        * )
            printf 'action %s not found\n' $__action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac
}

















private::user_add(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserCreate [name] [/GROUP:group] [/REALNAME:realname] [/NOTE:note]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserCreate ${__user[username]} /GROUP: /REALNAME:${__user[realname]} /NOTE:${__user[note]};
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::user_delete(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserDelete [name]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserDelete ${__user[username]};
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_pass(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserPasswordSet [name] [/PASSWORD:password]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserPasswordSet ${__user[username]} /PASSWORD:${__user[password]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_date(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserExpiresSet [name] [/EXPIRES:expires]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserExpiresSet ${__user[username]} /EXPIRES:\"${__user[expire]} 23:59:59\"
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_set(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        #  UserSet [name] [/GROUP:group] [/REALNAME:realname] [/NOTE:note]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserSet ${__user[username]} /GROUP:${__user[group]} /REALNAME:${__user[realname]} /NOTE:${__user[note]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_get(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserGet [name]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV  /CMD \
            UserGet ${__user[username]} | column -s, -t
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::user_list(){
    declare -n __user=${1};
    declare -n __server=${1};
    declare -n __hub=${2};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV  /CMD \
            UserList | column -s, -t
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

public::users(){
    declare -A __server_info __user_info __hub_info __action_list;
    declare -a __action_list_order;
    declare __server_name __hub_name __user_name __action __function;

    __action_list_order=(add delete pass date set get list);

    __action_list[add]='add a user'
    __action_list[delete]='delete a user'
    __action_list[pass]='set password for a user'
    __action_list[date]='set expire date date for a user'
    __action_list[set]='update a user user information'
    __action_list[get]='get info for a user'
    __action_list[list]='list of users'

    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq '.users | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __server_name="${1:? ... Error: __server_name ?}";
    shift 1;

    ### lookup server info in .servers
    while read -a objects; do
        __server_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".servers.${__server_name}" <<< "$__yaml");

    if [[ -n  ${__server_info[link]:-} ]]; then
        __server_info[cmd]="${__server_info[path]}/stable/vpncmd";
    else
        __server_info[cmd]="${__server_info[path]}/dev/build/vpncmd";
    fi
    
    private::debug $LINENO '!__server_info[@]:' "'${!__server_info[@]}'";
    private::debug $LINENO '__server_info[@]:' "'${__server_info[@]}'";

    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".users.${__server_name}[].hub" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __hub_name=${1};
    shift 1;

    while read -a objects; do
        __hub_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".users.${__server_name}[] | select(.hub==\"${__hub_name}\") | del(.users)" <<< "$__yaml");

    private::debug $LINENO '!__hub_info[@]:' "'${!__hub_info[@]}'";
    private::debug $LINENO '__hub_info[@]:' "'${__hub_info[@]}'";

    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".users.${__server_name}[] | select(.hub==\"${__hub_name}\") | .users[].username " <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __user_name=${1};
    shift 1;
    while read -a objects; do
        __user_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".users.${__server_name}[] | select(.hub==\"${__hub_name}\") | .users[] | select(.username==\"${__user_name}\") " <<< "$__yaml");

    if [[ -z ${__user_info[username]:-} ]]; then
        printf 'user: %s not found in %s of server %s\n' $__user_name $__hub_name $__server_name;
        exit $ERR_EXPR_FAILED;
    fi


    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action="$1";
    fi

    case ${__action} in
        add | delete | pass | date | set | get | list )
            printf '%s > %s > %s > %s\n' ${FUNCNAME##*:} $__server_name $__hub_name $__action;
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                 ssh ${__server_info[ssh]} "$(private::user_${__action} __server_info __hub_info __user_info)";
            elif [[ $REPLY == p ]]; then
                private::user_${__action} __server_info __hub_info __user_info;
            else
                printf 'cancelled\n';
            fi

        ;;
        * )
            printf 'action %s not found\n' $__action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac
}





public::peers(){
    if [[ -z ${1:-} ]]; then
        yq '.peers[].name' <<< "$__yaml"
        exit $EXIT_SUCCESS;
    fi

    declare __local_hub="${1:? ... Error: peers hub name?}";
    shift 1;

    if [[ -z ${1:-} ]]; then
        yq ".peers[] | select(.name==\"$__local_hub\") | .cascades[].name" <<< "$__yaml"
        exit $EXIT_SUCCESS;
    fi

    declare __p_cc_name="${1:? ... Error: peers hub cc name?}";
    shift 1;

    if [[ -z ${1:-} ]]; then
        for cmd in print init deinit online offline up donw get list; do
            printf '%s\n' $cmd;
        done
        exit $EXIT_SUCCESS;
    fi
    
    declare __p_action="${1:? ... Error: peers hub cc action??}";

    shift 1;
    if [[ $__p_action == 'print' ]]; then
        yq ".peers[] | select(.name==\"$__local_hub\") | .cascades[] | select(.name==\"$__p_cc_name\")" <<< "$__yaml";
        # yq ".peers[] | select(.name==\"$__local_hub\") " <<< "$__yaml";
    else
        cd ${__server[vpncmd]%vpncmd};
        # yq ".peers[] | select(.name==\"$__local_hub\") | .cascades[] | select(.name==\"$__p_cc_name\")" <<< "$__yaml" | public::${__p_action};
        yq ".peers[] | select(.name==\"$__local_hub\")" <<< "$__yaml" | public::${__p_action} $__p_cc_name;
    fi
    # $vpncmd /hub:$__local_hub /cmd help;

}










private::debug(){
    if [[ $SCRIPT_DEBUG_FLAG == true ]]; then
        private::warn "script($1)"  "${@:2}";
    fi
}

private::debug_x(){
    set -x;
}

private::main_help(){
    printf "$ANSISHELL_HEADER";

    printf "\n\nusage:\n";
    printf "$CLI_NAME [--options]\n";
    printf "$CLI_NAME command [--options]\n";
    printf "$CLI_NAME [--options] command [--options]\n";

    printf "\noptions:\n";
    printf "%-${HELP_OFFSET}s %s\n" '-h  | --help' 'show this help menu';
    printf "%-${HELP_OFFSET}s %s\n" '-v  | --version' 'show version';
    printf "%-${HELP_OFFSET}s %s\n" '-i  | --install' 'install this CLI';
    printf "%-${HELP_OFFSET}s %s\n" '-e  | --example' 'show some examples';
    printf "%-${HELP_OFFSET}s %s\n" '-d  | --debug' 'enable debugging (script level)';
    printf "%-${HELP_OFFSET}s %s\n" '-D  | --debug-x' 'enable bash debugging (bash level)';

    printf "\ncommands:\n";
    printf "%-${HELP_OFFSET}s %s\n" 'help' 'show help menu';
    printf "%-${HELP_OFFSET}s %s\n" 'peers' 'a user functions';
    printf "%-${HELP_OFFSET}s %s\n" 'init' 'a session functions';
    printf "%-${HELP_OFFSET}s %s\n" 'deinit' 'read SE server admin yaml file';
    printf "%-${HELP_OFFSET}s %s\n" 'online' 'send RPC-JSON to SE server';
    printf "%-${HELP_OFFSET}s %s\n" 'offline' 'parse SE server response';
    printf "%-${HELP_OFFSET}s %s\n" 'up' 'reset Bytes and Counts';
    printf "%-${HELP_OFFSET}s %s\n" 'down' 'reset Bytes and Counts';

    exit ${1:-1};
}

private::parse_options(){
    if (( ${#} == 0 )); then
        private::main_help 0;
    fi

    case $1 in
        -h | --help )
            private::main_help 0;
        ;;
        -d | --debug )
            SCRIPT_DEBUG_FLAG=true
            shift;
        ;;
        -D | --debug-x )
            private::debug_x;
            shift;
        ;;
        -e | --example )
            private::example;
            shift;
        ;;
        -v | --version )
            private::cli_version;
            shift;
        ;;
        -i | --install )
            private::cli_install;
        ;;
    esac

    if (( ${#} != 0 )); then
        private::debug $LINENO continue-main: "'$@'";
        private::main "$@";
    fi
}


private::main(){
    if (( ${#} == 0 )); then
        private::main_help 0;
    fi

    case ${1} in
        help | peers | servers | hubs | users )
            private::debug $LINENO 'command:' "'${1}'";
            private::debug $LINENO 'command-options:' "'${@:2}'";
            public::${1} "${@:2}";
        ;;
        * )
            private::parse_options "$@";
        ;;
    esac
}

private::main "$@";
