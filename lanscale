#!/bin/bash
#
# lanscale
# scale you LAN in minutes using SoftEther VPN
# Shakiba Moshiri (c) 20XX

################################################################################
# bash strict mode
################################################################################
private::strict_mode(){
    set -T # inherit DEBUG and RETURN trap for functions
    set -C # prevent file overwrite by > &> <>
    set -E # inherit -e
    set -e # exit immediately on errors
    set -u # exit on not assigned variables
    set -o pipefail # exit on pipe failure
}
private::strict_mode;

#four functions to change output in color
private::info() { printf "\033[1;34m${*}\033[0m\n"; }
private::warn() { printf "\033[1;33m${*}\033[0m\n" 1>&2; }
private::error(){ printf "\033[1;31m${*}\033[0m\n" 1>&2; }
private::title(){ printf "\033[1;37m${*}\033[0m\n"; }

# mutable variables
declare SCRIPT_DEBUG_FLAG=false;

# immutable variables
declare -ir ERR_EXPR_FAILED=1;
declare -ir ERR_FILE_NOT_FOUND=2;
declare -ir ERR_OPTION_NOT_FOUND=3;
declare -ir EXIT_SUCCESS=0;
declare -ir CLI_PPID=$$;

# declare -rA SUBCMD=([help]=help [config]=config [Test]=Test [EnumUser]=EnumUser);
declare -r PS4='debug($LINENO) ${FUNCNAME[0]:+${FUNCNAME[0]}}(): ';
declare -r CLI_NAME='lanscale';
declare -r CLI_VERSION='0.2.0';
declare -r CLI_INSTALL_PATH='/usr/local/bin';
declare -r HELP_OFFSET=20;
declare -r ANSISHELL_HEADER="\
 ┬  ┌─┐┌┐┌┌─┐┌─┐┌─┐┬  ┌─┐
 │  ├─┤│││└─┐│  ├─┤│  ├┤ 
 ┴─┘┴ ┴┘└┘└─┘└─┘┴ ┴┴─┘└─┘
 Scale Your LAN in minute";

declare -r __config_path='/etc/lanscale/yaml';

# mutable variables
declare __config_file="${__config_path}/lanscale.yaml"
declare __yaml="";

if [[ -f $__config_file ]]; then
    __yaml="$(yq '.' < $__config_file)";
else
    if ! [[ -f ${1:-} ]]; then
        private::warn "default '${CLI_NAME}.yaml' file not found";
        private::warn "default ${CLI_NAME}.yaml file can be placed in: '${__config_path}'";
        private::warn "expected file: '${__config_file}'";
    fi
fi

################################################################################
# utilit functions
################################################################################

# some SE server /CSV output field contain ","
# this function is for removing these
parse_csv(){
    if [[ -p /dev/stdin ]]; then
        cat /dev/stdin | perl -lne 'while (s/("[^",]+),/\1/g) { /"\d+","\d+"/ && s/"//g && print }' | column -s, -t
    fi
}

################################################################################
# servers commansd
################################################################################
private::server_install(){
    declare -n __server=$1;
    declare pre_server_install="function pre_server_install(){
        set -x;
        apt-get update -y
        apt-get install -y build-essential git curl tree wget pip python3
        pip install csvkit
    }";
    eval "$pre_server_install";
    pre_server_install="$(declare -f pre_server_install); pre_server_install;"
    printf '%s\n' "$pre_server_install";

    if [[ ${__server[version]} == stable ]]; then
        declare lanscale_server_install="function lanscale_server_install(){
            set -x
            mkdir -p ${__server[path]}
            cd ${__server[path]}
            ls -la
            wget --show-progress -qc  ${__server[link]}
            tar xzf ${__server[link]##*/}
            test -f vpnserver
            chmod 0755 vpnserver
            mv vpnserver stable
            cd stable
            chmod 600 *
            make
            ls -la
        }";

        eval "$lanscale_server_install";
        lanscale_server_install="$(declare -f lanscale_server_install); lanscale_server_install;"

        printf '%s\n' "$lanscale_server_install";
    elif [[ ${__server[version]} == 'dev' ]]; then
        declare lanscale_server_install="function lanscale_server_install(){
            set -x
            apt-get update -y
            apt-get install -y cmake gcc g++ make libncurses5-dev libssl-dev libsodium-dev libreadline-dev zlib1g-dev pkg-config
            mkdir -p ${__server[path]}
            cd ${__server[path]}
            ls -la
            git clone ${__server[repo]} dev || true
            cd dev
            git submodule init
            git submodule update
            ./configure
            make -C build
            cd build
            ls -la
        }";

        eval "$lanscale_server_install";
        lanscale_server_install="$(declare -f lanscale_server_install); lanscale_server_install;"

        printf '%s\n' "$lanscale_server_install";
    else
        printf '%s has no match\n' ${__server[version]};
    fi
}

private::server_systemd(){
    declare -n __server=$1;

    declare install_systemd="function install_systemd(){
        set -x;
        echo '[Unit]
Description=SoftEther VPN Server
After=network.target auditd.service

[Service]
Type=forking
TasksMax=infinity
EnvironmentFile=-${__server[cmd]%/vpncmd}
ExecStart=${__server[cmd]%/vpncmd}/vpnserver start
ExecStop=${__server[cmd]%/vpncmd}/vpnserver stop
KillMode=process
Restart=on-failure

# Hardening
PrivateTmp=yes
ProtectHome=yes
ProtectSystem=full
ReadOnlyDirectories=/
ReadWriteDirectories=-${__server[cmd]%/vpncmd}

[Install]
WantedBy=multi-user.target' > /usr/lib/systemd/system/se-${__server[version]}.service;

        systemctl daemon-reload
    }";

    eval "$install_systemd";
    install_systemd="$(declare -f install_systemd); install_systemd;"

    printf '%s\n' "$install_systemd";
}

private::server_pass(){
    declare -n __server=$1;

    # vpncmd [host:port] [/CLIENT|/SERVER|/TOOLS] [/HUB:hub] [/ADMINHUB:adminhub] [/PASSWORD:password] [/IN:infile] [/OUT:outfile] [/CMD commands...]

    declare lanscale_server_pass="function lanscale_server_pass(){
        set -x;
        test -f ${__server[cmd]}
        cd ${__server[cmd]%/*}
        ./vpnserver start
        while true; do
            if ! curl -sk https://127.0.0.1:443 -o /dev/null; then
                sleep 1
                continue
            else
                break
            fi
        done
        ${__server[cmd]} localhost:443 /SERVER /PASSWORD: /CSV /CMD  ServerPasswordSet ${__server[pass]}
        ${__server[cmd]} localhost:443 /SERVER /PASSWORD:${__server[pass]} /CSV /CMD HubDel DEFAULT
        cd ${__server[cmd]%/*}
        ./vpnserver stop
    }";

    eval "$lanscale_server_pass";
    lanscale_server_pass="$(declare -f lanscale_server_pass); lanscale_server_pass;"

    printf '%s\n' "$lanscale_server_pass";
}

private::server_start(){
    declare -n __server=$1;
    declare lanscale_server_start;

    if [[ ${__server[version]} == 'stable' ]]; then
        lanscale_server_start="function lanscale_server_start(){
            set -x;
            systemctl start se-stable.service
        }";
    elif [[ ${__server[version]} == 'dev' ]]; then
        lanscale_server_start="function lanscale_server_start(){
            set -x;
            systemctl start se-dev.service
        }";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    eval "$lanscale_server_start";
    lanscale_server_start="$(declare -f lanscale_server_start); lanscale_server_start;"

    printf '%s\n' "$lanscale_server_start";
}

private::server_stop(){
    declare -n __server=$1;
    declare lanscale_server_stop;

    if [[ ${__server[version]} == 'stable' ]]; then
        lanscale_server_stop="function lanscale_server_stop(){
            set -x;
            systemctl stop se-stable.service
        }";
    elif [[ ${__server[version]} == 'dev' ]]; then
        lanscale_server_stop="function lanscale_server_stop(){
            set -x;
            systemctl stop se-dev.service
        }";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    eval "$lanscale_server_stop";
    lanscale_server_stop="$(declare -f lanscale_server_stop); lanscale_server_stop;"

    printf '%s\n' "$lanscale_server_stop";
}

private::server_restart(){
    declare -n __server=$1;
    declare lanscale_server_restart;

    if [[ ${__server[version]} == 'stable' ]]; then
        lanscale_server_restart="function lanscale_server_restart(){
            set -x;
            systemctl restart se-stable.service
        }";
    elif [[ ${__server[version]} == 'dev' ]]; then
        lanscale_server_restart="function lanscale_server_restart(){
            set -x;
            systemctl restart se-dev.service
        }";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    eval "$lanscale_server_restart";
    lanscale_server_restart="$(declare -f lanscale_server_restart); lanscale_server_restart;"

    printf '%s\n' "$lanscale_server_restart";
}

private::server_status(){
    declare -n __server=$1;

    declare lanscale_server_status="function lanscale_server_status(){
        set -x;
        test -f ${__server[cmd]}
        while true; do
            if ! curl -sk https://127.0.0.1:443 -o /dev/null; then
                sleep 1
                continue
            else
                break
            fi
        done
        ${__server[cmd]} localhost:443 /SERVER /PASSWORD:${__server[pass]} /CSV /CMD ServerStatusGet  | csvlook
    }";

    eval "$lanscale_server_status";
    lanscale_server_status="$(declare -f lanscale_server_status); lanscale_server_status;"

    printf '%s\n' "$lanscale_server_status";
}

private::server_info(){
    declare -n __server=$1;

    declare lanscale_server_info="function lanscale_server_info(){
        set -x;
        test -f ${__server[cmd]}
        ${__server[cmd]} localhost:443 /SERVER /PASSWORD:${__server[pass]} /CSV /CMD ServerInfoGet | csvlook
    }";

    eval "$lanscale_server_info";
    lanscale_server_info="$(declare -f lanscale_server_info); lanscale_server_info;"

    printf '%s\n' "$lanscale_server_info";
}

private::server_init(){
    private::server_install $@;
    private::server_systemd $@;
    private::server_pass $@;
    private::server_start $@;
    private::server_status $@;
}

# ServerCertGet        - Get SSL Certificate of VPN Server
# ServerCertRegenerate - Generate New Self-Signed Certificate with Specified CN (Common Name) and Register on VPN Server
# ServerCertSet        - Set SSL Certificate and Private Key of VPN Server
# ServerCipherGet      - Get the Encrypted Algorithm Used for VPN Communication.
# ServerCipherSet      - Set the Encrypted Algorithm Used for VPN Communication.
# ServerInfoGet        - Get server information
# ServerKeyGet         - Get SSL Certificate Private Key of VPN Server
# ServerPasswordSet    - Set VPN Server Administrator Password
# ServerStatusGet      - Get Current Server Status
public::servers(){
    declare -A __server_info __action_list;
    declare -a __action_list_order;
    declare __s_name __s_action __server_version;

    __action_list_order=(install systemd pass start stop restart status info init);

    __action_list[install]='install SoftEther VPN server'
    __action_list[systemd]='install systemd service'
    __action_list[start]='start systemd serivce'
    __action_list[stop]='stop systemd service'
    __action_list[restart]='restart systemd service';
    __action_list[pass]='set password for admin';
    __action_list[status]='get status of a server';
    __action_list[info]='get information of a server';
    __action_list[print]='print yaml key-value';
    __action_list[init]='install, systemd, pass, start, status';

    if [[ -z ${1:-} ]]; then
        while read name; do
            echo $name;
        done < <(yq '.servers | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __s_name="${1}";

    while read -a objects; do
        __server_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".servers.${__s_name}" <<< "$__yaml");

    if [[ -z ${2:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __s_action="$2";
    fi


    if [[ -n  ${__server_info[link]:-} ]]; then
        __server_info[version]='stable';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/vpncmd";
    else
        __server_info[version]='dev';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/build/vpncmd";
    fi
    

    case $__s_action in
        print )
            for key in ${!__server_info[@]}; do
                printf '%-10s %s\n' ${key} ${__server_info[$key]};
            done
        ;;
        install | systemd | pass | start | stop | restart | status | info | init )
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                ssh ${__server_info[ssh]} "$(private::server_$__s_action __server_info)"
            elif [[ $REPLY == p ]]; then
                private::server_$__s_action __server_info;
            else
                printf 'cancelled\n';
            fi
        ;;

        * )
            printf 'action %s not found\n' $__s_action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac
}


################################################################################
# hubs commands
################################################################################
private::hub_add(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        declare -x tap_net=${__hub[net]:-};
        # HubCreate [name] [/PASSWORD:password]
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
          HubCreate ${__hub[hub]} /PASSWORD:${__server[pass]}

        # BridgeCreate [hubname] [/DEVICE:device_name] [/TAP:yes|no]
        # DO NOT ADD hub for /SERVER
        # it did not work
        ${__server[cmd]} localhost:443 /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \
            BridgeCreate ${__hub[hub]} /TAP:yes /DEVICE:${__hub[hub]}

        while true; do
            if ! ip -br a show tap_${__hub[hub],,}; then
                sleep 1
                continue
            else
                ip address add \${tap_net} brd + dev tap_${__hub[hub],,}
                break
            fi
        done

        iptables -t nat -A POSTROUTING -s \${tap_net} ! -d \${tap_net} -o ${__hub[inet]} -j SNAT --to-source ${__hub[snat]}
        sysctl -w net.ipv4.ip_forward=1
        sysctl -p
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_delete(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # HubCreate [name] [/PASSWORD:password]
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
            HubDelete ${__hub[hub]}

        ${__server[cmd]} localhost:443 /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \
            BridgeDelete ${__hub[hub]} /DEVICE:${__hub[hub]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_online(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/Online
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            Online
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_offline(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/Offline
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            Offline
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_status(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # Hub/StatusGet
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            StatusGet | csvlook
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::hub_list(){
    declare -n __server=${1};
    declare -n __hub=${2};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # HubList
        ${__server[cmd]} localhost:443 /SERVER /HUB: /PASSWORD:${__server[pass]} /CSV /CMD \
            HubList | csvlook
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

# Hub              - Select Virtual Hub to Manage
# HubCreate        - Create New Virtual Hub
# HubCreateDynamic - Create New Dynamic Virtual Hub (For Clustering)
# HubCreateStatic  - Create New Static Virtual Hub (For Clustering)
# HubDelete        - Delete Virtual Hub
# HubList          - Get List of Virtual Hubs
# HubSetDynamic    - Change Virtual Hub Type to Dynamic Virtual Hub
# HubSetStatic     - Change Virtual Hub Type to Static Virtual Hub
#
#
# BridgeCreate     - Create Local Bridge Connection
# BridgeDelete     - Delete Local Bridge Connection
# BridgeDeviceList - Get List of Network Adapters Usable as Local Bridge
# BridgeList       - Get List of Local Bridge Connection
public::hubs(){
    declare -A __hub_info __server_info __action_list __;
    declare -a __action_list_order;
    declare __server_name __hub_name __action __function;

    __action_list_order=(add delete online offline status list print);

    __action_list[add]='add a hub'
    __action_list[delete]='delete a hub'
    __action_list[online]='make a hub online'
    __action_list[offline]='make a hub offline'
    __action_list[list]='list all hub(s)'
    __action_list[status]='status a hub offline'
    __action_list[print]='print yaml key-value'

    ### match server name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq '.hubs | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __server_name=${1};
    shift 1;
    
    ### lookup server info in .servers
    while read -a objects; do
        __server_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".servers.${__server_name}" <<< "$__yaml");

    if [[ -n  ${__server_info[link]:-} ]]; then
        __server_info[version]='stable';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/vpncmd";
    else
        __server_info[version]='dev';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/build/vpncmd";
    fi
    
    private::debug $LINENO '!__server_info[@]:' "'${!__server_info[@]}'";
    private::debug $LINENO '__server_info[@]:' "'${__server_info[@]}'";

    ### match hub name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".hubs.${__server_name}[].hub" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __hub_name=${1};
    shift 1;

    while read -a objects; do
        __hub_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".hubs.${__server_name}[] | select(.hub==\"${__hub_name}\") " <<< "$__yaml");

    private::debug $LINENO '!__hub_info[@]:' "'${!__hub_info[@]}'";
    private::debug $LINENO '__hub_info[@]:' "'${__hub_info[@]}'";

    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action="$1";
    fi




    case ${__action} in
        print )
            for key in ${!__hub_info[@]}; do
                printf '%-10s %s\n' ${key} ${__hub_info[$key]};
            done
        ;;
        add | delete | online | offline | status | list )
            printf '%s > %s > %s > %s\n' ${FUNCNAME##*:} $__server_name $__hub_name $__action;
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                 ssh ${__server_info[ssh]} "$(private::hub_${__action} __server_info __hub_info)";
            elif [[ $REPLY == p ]]; then
                private::hub_${__action} __server_info __hub_info;
            else
                printf 'cancelled\n';
            fi

        ;;
        * )
            printf 'action %s not found\n' $__action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac
}

################################################################################
# users commands
################################################################################
private::user_create(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserCreate [name] [/GROUP:group] [/REALNAME:realname] [/NOTE:note]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserCreate ${__user[user]} /GROUP: /REALNAME:${__user[real]} /NOTE:${__user[note]};
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::user_delete(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserDelete [name]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserDelete ${__user[user]};
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_pass(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserPasswordSet [name] [/PASSWORD:password]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserPasswordSet ${__user[user]} /PASSWORD:${__user[pass]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_date(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare expire_date=$(date -d "+ ${__user[expire]} days" '+%Y/%m/%d');

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserExpiresSet [name] [/EXPIRES:expires]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserExpiresSet ${__user[user]} /EXPIRES:\"$expire_date 23:59:59\"
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_set(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        #  UserSet [name] [/GROUP:group] [/REALNAME:realname] [/NOTE:note]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV /CMD \
            UserSet ${__user[user]} /GROUP:${__user[group]} /REALNAME:${__user[real]} /NOTE:${__user[note]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}
private::user_get(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __user=${3};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # UserGet [name]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV  /CMD \
            UserGet ${__user[user]} | csvlook
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::user_list(){
    declare -n __user=${1};
    declare -n __server=${1};
    declare -n __hub=${2};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[hub]} /PASSWORD:${__server[pass]} /CSV  /CMD \
            UserList | csvlook
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::user_add(){
    private::user_create $@;
    private::user_pass $@;
    private::user_date $@;
}

public::users(){
    declare -A __server_info __user_info __hub_info __action_list;
    declare -a __action_list_order;
    declare __server_name __hub_name __user_name __action __function;

    __action_list_order=(create delete pass date set get list add print);

    __action_list[create]='create a user'
    __action_list[delete]='delete a user'
    __action_list[pass]='set password for a user'
    __action_list[date]='set expire date date for a user'
    __action_list[set]='update a user user information'
    __action_list[get]='get info for a user'
    __action_list[list]='list of users'
    __action_list[add]='create, pass, date'
    __action_list[print]='print yaml key-value'

    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq '.users | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __server_name="${1:? ... Error: __server_name ?}";
    shift 1;

    ### lookup server info in .servers
    while read -a objects; do
        __server_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".servers.${__server_name}" <<< "$__yaml");

    if [[ -n  ${__server_info[link]:-} ]]; then
        __server_info[version]='stable';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/vpncmd";
    else
        __server_info[version]='dev';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/build/vpncmd";
    fi
    
    private::debug $LINENO '!__server_info[@]:' "'${!__server_info[@]}'";
    private::debug $LINENO '__server_info[@]:' "'${__server_info[@]}'";

    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".users.${__server_name}[].hub" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __hub_name=${1};
    shift 1;

    while read -a objects; do
        __hub_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".users.${__server_name}[] | select(.hub==\"${__hub_name}\") | del(.members)" <<< "$__yaml");

    private::debug $LINENO '!__hub_info[@]:' "'${!__hub_info[@]}'";
    private::debug $LINENO '__hub_info[@]:' "'${__hub_info[@]}'";

    if [[ -z ${1:-} ]]; then
        while read user real; do
            printf '%s %s\n' $user $real;
        done < <(yq ".users.${__server_name}[] | select(.hub==\"${__hub_name}\") | .members[] | .user + \" \" + .real" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __user_name=${1};
    shift 1;
    while read -a objects; do
        __user_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".users.${__server_name}[] | select(.hub==\"${__hub_name}\") | .members[] | select(.user==\"${__user_name}\") " <<< "$__yaml");

    if [[ -z ${__user_info[user]:-} ]]; then
        printf 'user: %s not found in %s of server %s\n' $__user_name $__hub_name $__server_name;
        exit $ERR_EXPR_FAILED;
    fi


    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action="$1";
    fi

    case ${__action} in
        print )
            for key in ${!__user_info[@]}; do
                printf '%-10s %s\n' ${key} ${__user_info[$key]}
            done
        ;;
        create | delete | pass | date | set | get | list | add )
            printf '%s > %s > %s > %s\n' ${FUNCNAME##*:} $__server_name $__hub_name $__action;
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                 ssh ${__server_info[ssh]} "$(private::user_${__action} __server_info __hub_info __user_info)";
            elif [[ $REPLY == p ]]; then
                private::user_${__action} __server_info __hub_info __user_info;
            else
                printf 'cancelled\n';
            fi

        ;;
        * )
            printf 'action %s not found\n' $__action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac
}

################################################################################
# groups commands
################################################################################
private::group_create(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __group=${3};
    declare -n __policy=${4};
    declare group_policy_set='';
    for key in ${!__policy[@]}; do
        group_policy_set+="${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[name]} /PASSWORD:${__server[pass]} /CSV  /CMD GroupPolicySet ${__group[name]} /NAME:$key /VALUE:${__policy[$key]}";
        group_policy_set+=$'\n';
    done

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # GroupCreate [name] [/REALNAME:realname] [/NOTE:note]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[name]} /PASSWORD:${__server[pass]} /CSV  /CMD \
            GroupCreate ${__group[name]} /REALNAME:${__group[real]} /NOTE:${__group[note]}

        # GroupPolicySet [name] [/NAME:policy_name] [/VALUE:num|yes|no]
        $group_policy_set
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::group_delete(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __group=${3};
    declare -n __policy=${4};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[name]} /PASSWORD:${__server[pass]} /CSV /CMD \
            GroupDelete ${__group[name]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::group_get(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __group=${3};
    declare -n __policy=${4};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # GroupGet [name]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[name]} /PASSWORD:${__server[pass]} /CSV /CMD \
            GroupGet ${__group[name]} | column -s, -t
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::group_set(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __group=${3};
    declare -n __policy=${4};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        # GroupSet [name] [/REALNAME:realname] [/NOTE:note]
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[name]} /PASSWORD:${__server[pass]} /CSV /CMD \
            GroupSet ${__group[name]} /REALNAME:${__group[real]} /NOTE:${__group[note]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::group_list(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __group=${3};
    declare -n __policy=${4};
    
    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        ${__server[cmd]} localhost:443 /SERVER /HUB:${__hub[name]} /PASSWORD:${__server[pass]} /CSV  /CMD \
            GroupList | csvlook
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

# GroupCreate       - Create Group
# GroupDelete       - Delete Group
# GroupGet          - Get Group Information and List of Assigned Users
# GroupJoin         - Add User to Group
# GroupList         - Get List of Groups
# GroupPolicyRemove - Delete Group Security Policy
# GroupPolicySet    - Set Group Security Policy
# GroupSet          - Set Group Information
# GroupUnjoin       - Delete User from Group
public::groups(){
    declare -A __server_info __group_info __hub_info __policy_info __action_list;
    declare -a __action_list_order;
    declare __server_name __hub_name __group_name __action __function;

    __action_list_order=(create delete set get list print);

    __action_list[create]='create a group'
    __action_list[delete]='delete a group'
    __action_list[set]='update a group information'
    __action_list[get]='get info for a group'
    __action_list[list]='list of groups'
    __action_list[print]='print yaml key-value'

    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq '.groups | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __server_name="${1:? ... Error: __server_name ?}";
    shift 1;

    ### lookup server info in .servers
    while read -a objects; do
        __server_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".servers.${__server_name}" <<< "$__yaml");

    if [[ -n  ${__server_info[link]:-} ]]; then
        __server_info[version]='stable';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/vpncmd";
    else
        __server_info[version]='dev';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/build/vpncmd";
    fi
    
    private::debug $LINENO '!__server_info[@]:' "'${!__server_info[@]}'";
    private::debug $LINENO '__server_info[@]:' "'${__server_info[@]}'";

    ### find hub name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".groups.${__server_name}[].hub" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __hub_name=${1};
    __hub_info[name]=${1};
    shift 1;

    private::debug $LINENO '!__hub_info[@]:' "'${!__hub_info[@]}'";
    private::debug $LINENO '__hub_info[@]:' "'${__hub_info[@]}'";

    ### print name to select from
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".groups.${__server_name}[] | select(.hub==\"${__hub_name}\") | .list[].name" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi

    __group_name=${1};
    shift 1;

    ### map group info
    while read -a objects; do
        __group_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".groups.${__server_name}[] | select(.hub==\"${__hub_name}\") | .list[] | select(.name==\"${__group_name}\") | del(.policy)" <<< "$__yaml");
    
    ### map policy info
    while read -a objects; do
        __policy_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".groups.${__server_name}[] | select(.hub==\"${__hub_name}\") | .list[] | select(.name==\"${__group_name}\") | .policy" <<< "$__yaml");

    if [[ -z ${__group_info[name]:-} ]]; then
        printf 'group: %s not found in %s of server %s\n' $__group_name $__hub_name $__server_name;
        exit $ERR_EXPR_FAILED;
    fi

    # print actions
    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action="$1";
    fi

    case ${__action} in
        print )
            for key in ${!__group_info[@]}; do
                printf '%-10s %s\n' ${key} ${__group_info[$key]}
            done
            for key in ${!__policy_info[@]}; do
                printf '%-20s %s\n' ${key} ${__policy_info[$key]}
            done
        ;;
        create | delete | get | set | list )
            printf '%s > %s > %s > %s\n' ${FUNCNAME##*:} $__server_name $__hub_name $__action;
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                 ssh ${__server_info[ssh]} "$(private::group_${__action} __server_info __hub_info __group_info __policy_info)";
            elif [[ $REPLY == p ]]; then
                private::group_${__action} __server_info __hub_info __group_info __policy_info;
            else
                printf 'cancelled\n';
            fi

        ;;
        * )
            printf 'action %s not found\n' $__action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac
}

################################################################################
# cascades commands
################################################################################
private::cascade_add(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __peer=${3};

    if [[ ${__server[version]} == 'stable' ]]; then
        __bin_path="${__server[path]}/${__server[version]}";
    elif [[ ${__server[version]} == 'dev' ]]; then
        __bin_path="${__server[path]}/${__server[version]}/build";
    else
        printf '%s has no match\n' ${__server[version]};
    fi

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        test -f ${__bin_path}/vpncmd
        test -f ${__bin_path}/vpnserver

        # CascadeCreate [name] [/SERVER:hostname:port] [/HUB:hubname] [/USERNAME:username]
        # CascadeCreate ${__peer[name]} /server:${__peer[host]}:${__peer[port]}  /HUB:${__peer[hub]} /USERNAME:${__peer[user]}
        $__bin_path/vpncmd localhost:443 /HUB:${__hub[hub]} /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \
            CascadeCreate ${__peer[name]} /server:${__peer[host]}:${__peer[port]}  /HUB:${__peer[hub]} /USERNAME:${__peer[user]}

        # CascadePasswordSet [name] [/PASSWORD:password] [/TYPE:standard|radius]
        $__bin_path/vpncmd localhost:443 /HUB:${__hub[hub]} /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \
            CascadePasswordSet ${__peer[name]} /PASSWORD:${__peer[pass]} /type:standard
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::cascade_delete(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __peer=${3}

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        test -f ${__server[cmd]}

        # CascadeDelete [name]
        ${__server[cmd]} localhost:443 /HUB:${__hub[hub]} /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \
            CascadeDelete ${__peer[name]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::cascade_online(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __peer=${3}

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        test -f ${__server[cmd]}

        # CascadeOnline [name]
        ${__server[cmd]} localhost:443 /HUB:${__hub[hub]} /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \
            CascadeOnline ${__peer[name]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::cascade_offline(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __peer=${3}

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        test -f ${__server[cmd]}

        # CascadeOnline [name]
        ${__server[cmd]} localhost:443 /HUB:${__hub[hub]} /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \
            CascadeOffline ${__peer[name]}
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

private::cascade_list(){
    declare -n __server=${1};
    declare -n __hub=${2};
    declare -n __peer=${3}

    echo __hub: "${__hub[@]}"

    declare lanscale_ssh_fn="function lanscale_ssh_fn(){
        set -x;
        test -f ${__server[cmd]}

        # CascadeList
        # why admin cannot access a hub with addmin password
        # ${__server[cmd]} localhost:443 /HUB:${__hub[hub]} /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \

        ${__server[cmd]} localhost:443 /HUB:${__hub[hub]} /SERVER /PASSWORD:${__server[pass]} /CSV /CMD \
            CascadeList | csvlook
    }";

    eval "$lanscale_ssh_fn";
    lanscale_ssh_fn="$(declare -f lanscale_ssh_fn); lanscale_ssh_fn;"

    printf '%s\n' "$lanscale_ssh_fn";
}

# CascadeAnonymousSet      - Set User Authentication Type of Cascade Connection to Anonymous Authentication
# CascadeCertGet           - Get Client Certificate to Use for Cascade Connection
# CascadeCertSet           - Set User Authentication Type of Cascade Connection to Client Certificate Authentication
# CascadeCompressDisable   - Disable Data Compression when Communicating by Cascade Connection
# CascadeCompressEnable    - Enable Data Compression when Communicating by Cascade Connection
# CascadeCreate            - Create New Cascade Connection
# CascadeDefaultCADisable  - Disable Trust System Certificate Store Option
# CascadeDefaultCAEnable   - Enable Trust System Certificate Store Option
# CascadeDelete            - Delete Cascade Connection Setting
# CascadeDetailSet         - Set Advanced Settings for Cascade Connection
# CascadeEncryptDisable    - Disable Encryption when Communicating by Cascade Connection
# CascadeEncryptEnable     - Enable Encryption when Communicating by Cascade Connection
# CascadeGet               - Get the Cascade Connection Setting
# CascadeHttpHeaderAdd     - Add a custom value in the HTTP header sent to the proxy server
# CascadeHttpHeaderDelete  - Delete a custom value in the HTTP header sent to the proxy server
# CascadeHttpHeaderGet     - Get the list of custom values in the HTTP header sent to the proxy server
# CascadeList              - Get List of Cascade Connections
# CascadeOffline           - Switch Cascade Connection to Offline Status
# CascadeOnline            - Switch Cascade Connection to Online Status
# CascadePasswordSet       - Set User Authentication Type of Cascade Connection to Password Authentication
# CascadePolicySet         - Set Cascade Connection Session Security Policy
# CascadeProxyHttp         - Set Connection Method of Cascade Connection to be via an HTTP Proxy Server
# CascadeProxyNone         - Specify Direct TCP/IP Connection as the Connection Method of Cascade Connection
# CascadeProxySocks        - Set Connection Method of Cascade Connection to be via a SOCKS4 Proxy Server
# CascadeProxySocks5       - Set Connection Method of Cascade Connection to be via a SOCKS5 Proxy Server
# CascadeRename            - Change Name of Cascade Connection
# CascadeServerCertDelete  - Delete the Server Individual Certificate for Cascade Connection
# CascadeServerCertDisable - Disable Cascade Connection Server Certificate Verification Option
# CascadeServerCertEnable  - Enable Cascade Connection Server Certificate Verification Option
# CascadeServerCertGet     - Get the Server Individual Certificate for Cascade Connection
# CascadeServerCertSet     - Set the Server Individual Certificate for Cascade Connection
# CascadeSet               - Set the Destination for Cascade Connection
# CascadeStatusGet         - Get Current Cascade Connection Status
# CascadeUsernameSet       - Set User Name to Use Connection of Cascade Connection
public::cascades(){
    declare -A __server_info __hub_info __peer_info __action_list;
    declare -a __action_list_order;
    declare __action __server_info_name __hub_name __peer_info_name;

    __action_list_order=(add delete online offline list print);

    __action_list[add]='add a cascade'
    __action_list[delete]='delete a cascade'
    __action_list[online]='make a cascade online'
    __action_list[offline]='make a cascade offline'
    __action_list[list]='list all cascades'
    __action_list[print]='print yaml key-value'

    ### match server name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq '.cascades | keys | .[]' <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __server_info_name=${1};
    shift 1;

    ### lookup server info in .servers
    while read -a objects; do
        __server_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".servers.${__server_info_name}" <<< "$__yaml");

    if [[ -n  ${__server_info[link]:-} ]]; then
        __server_info[version]='stable';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/vpncmd";
    else
        __server_info[version]='dev';
        __server_info[cmd]="${__server_info[path]}/${__server_info[version]}/build/vpncmd";
    fi

    private::debug $LINENO '!__server_info[@]:' "'${!__server_info[@]}'";
    private::debug $LINENO '__server_info[@]:' "'${__server_info[@]}'";

    ### match a hub name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".cascades.${__server_info_name}[].hub" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __hub_name=${1};
    __hub_info[hub]=${1};
    shift 1;

    ### match a peer name
    if [[ -z ${1:-} ]]; then
        while read name; do
            printf '%s\n' $name;
        done < <(yq ".cascades.${__server_info_name}[] | select(.hub==\"${__hub_name}\") | .peers[].name" <<< "$__yaml");
        exit $EXIT_SUCCESS;
    fi
    __peer_info_name=${1};
    shift 1;

    ### get a peer info
    while read -a objects; do
        __peer_info[${objects[0]%:}]=${objects[1]};
    done < <(yq ".cascades.${__server_info_name}[] | select(.hub==\"${__hub_name}\") | .peers[] | select(.name==\"${__peer_info_name}\")" <<< "$__yaml");

    private::debug $LINENO '!__peer_info[@]:' "'${!__peer_info[@]}'";
    private::debug $LINENO '__peer_info[@]:' "'${__peer_info[@]}'";



    if [[ -z ${1:-} ]]; then
        for value in ${__action_list_order[@]}; do
            printf '%-10s %s\n' $value "${__action_list[$value]}"
        done
        exit $EXIT_SUCCESS;
    else
        __action="$1";
    fi

    case ${__action} in
        print )
            for key in ${!__peer_info[@]}; do
                printf '%-10s %s\n' $key ${__peer_info[$key]};
            done
        ;;
        add | delete | online | offline | set | get | list )
            printf '%s > %s > %s > %s\n' ${FUNCNAME##*:} $__server_info_name $__hub_name $__action;
            # printf 'peer < %s < %s < %s\n' ${__peer_info[host]} ${__peer_info[hub]} ${__peer_info[name]}
            read -p 'continue? [p/n/Y] ';
            if [[ $REPLY == Y || $REPLY == y ]]; then
                 ssh ${__server_info[ssh]} "$(private::cascade_${__action} __server_info __hub_info __peer_info)";
            elif [[ $REPLY == p ]]; then
                private::cascade_${__action} __server_info __hub_info __peer_info;
            else
                printf 'cancelled\n';
            fi

        ;;
        * )
            printf 'action %s not found\n' $__action;
            exit $ERR_EXPR_FAILED;
        ;;
    esac
}


################################################################################
# main function
################################################################################
private::example(){
    echo example for $CLI_NAME;
    echo not implemented yet
}

private::cli_install(){
    if which $CLI_NAME > /dev/null 2>&1 ; then
        md5sum ./$CLI_NAME
        md5sum $CLI_INSTALL_PATH/$CLI_NAME;
        read -p "Already $CLI_NAME has been installed, want to overwrite [y/n]? " user_choice;
        case $user_choice in
            y )
                sudo install $CLI_NAME -t $CLI_INSTALL_PATH/
                which $CLI_NAME;
            ;;
            * )
                printf "installing $0 cancelled\n";
                exit $EXIT_SUCCESS;

            ;;
        esac
    else
        sudo install $CLI_NAME -t $CLI_INSTALL_PATH/
        which $CLI_NAME;
    fi

    exit $?;
}

private::cli_version(){
    printf "%s %s\n" $CLI_NAME $CLI_VERSION;
    exit $EXIT_SUCCESS;
}

private::debug(){
    if [[ $SCRIPT_DEBUG_FLAG == true ]]; then
        private::warn "script($1)"  "${@:2}";
    fi
}

private::debug_x(){
    set -x;
}

public::help(){
    printf "$ANSISHELL_HEADER";

    printf "\n\nusage:\n";
    printf "$CLI_NAME [--options]\n";
    printf "$CLI_NAME [--options] command [select objects]\n";

    printf "\noptions:\n";
    printf "%-${HELP_OFFSET}s %s\n" '-h  | --help' 'show this help menu';
    printf "%-${HELP_OFFSET}s %s\n" '-v  | --version' 'show version';
    printf "%-${HELP_OFFSET}s %s\n" '-i  | --install' 'install this CLI';
    printf "%-${HELP_OFFSET}s %s\n" '-e  | --example' 'show some examples';
    printf "%-${HELP_OFFSET}s %s\n" '-d  | --debug' 'enable debugging (script level)';
    printf "%-${HELP_OFFSET}s %s\n" '-D  | --debug-x' 'enable bash debugging (bash level)';

    printf "\ncommands:\n";
    printf "%-${HELP_OFFSET}s %s\n" 'servers' 'manage servers';
    printf "%-${HELP_OFFSET}s %s\n" 'hubs' 'manage hubs';
    printf "%-${HELP_OFFSET}s %s\n" 'users' 'manage users';
    printf "%-${HELP_OFFSET}s %s\n" 'cascades' 'manage cascade connections';

    exit ${1:-1};
}

private::parse_options(){
    if (( ${#} == 0 )); then
        public::help 0;
    fi

    case $1 in
        -h | --help )
            public::help 0;
        ;;
        -d | --debug )
            SCRIPT_DEBUG_FLAG=true
            shift;
        ;;
        -D | --debug-x )
            private::debug_x;
            shift;
        ;;
        -e | --example )
            private::example;
            shift;
        ;;
        -v | --version )
            private::cli_version;
            shift;
        ;;
        -i | --install )
            private::cli_install;
        ;;
    esac

    if (( ${#} != 0 )); then
        case ${1} in
            help | servers | hubs | users | groups | cascades )
                private::debug $LINENO continue-main: "'$@'";
                private::main "$@";
            ;;
            * )
                printf "command: '%s' not found\n" $1;
                exit $ERR_EXPR_FAILED;
            ;;
        esac
    fi
}

private::main(){
    if (( ${#} == 0 )); then
        if [[ -f $__config_file ]]; then
            yq '. | keys | .[]' <<< $__yaml;
            exit $EXIT_SUCCESS;
        else
            public::help 0;
        fi
    fi

    if [[ -f ${1} ]]; then
        __config_file="${PWD}/${1}"
        __yaml="$(yq '.' < $__config_file)";
        if (( ${#} > 1 )); then
            shift 1;
        else
            yq '. | keys | .[]' ${1};
            exit $EXIT_SUCCESS;
        fi
    fi

    case ${1} in
        help | servers | hubs | users | groups | cascades )
            private::debug $LINENO 'command:' "'${1}'";
            private::debug $LINENO 'command-options:' "'${@:2}'";
            public::${1} "${@:2}";
        ;;
        * )
            private::parse_options "$@";
        ;;
    esac
}

private::main "$@";
